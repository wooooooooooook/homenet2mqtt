name: Generate Gallery List

on:
  push:
    branches: [main]
    paths:
      - 'gallery/**/*.yaml'
      - 'gallery/**/*.yml'
      - 'gallery/**/requirements.json'
  workflow_dispatch:

jobs:
  generate-list:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: main

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install js-yaml
        run: npm install -g js-yaml

      - name: Generate list.json and list_new.json
        run: |
          export NODE_PATH=$(npm root -g)
          node << 'EOF'
          const fs = require('fs');
          const path = require('path');
          const yaml = require('js-yaml');

          const galleryDir = './gallery';
          const vendorsLegacy = {};  // Without parameters/discovery
          const vendorsNew = {};     // With parameters/discovery

          // Vendor display names
          const vendorNames = {
            kocom: '코콤',
            kocom_theart: '코콤 Theart',
            kocom_thinks: '코콤 Thinks',
            commax: '코맥스',
            hyundai_imazu: '현대 imazu',
            hyundai_imazu_doorbell: '현대 imazu 현관문(주방폰)',
            ezville: '이지빌',
            samsung_sds: '삼성 SDS',
            cvnet: 'CVNet',
            'bestin': 'BESTIN',
            'bestin2.0': 'BESTIN2.0',
          };

          // Find all YAML files in gallery subdirectories
          const vendorDirs = fs.readdirSync(galleryDir, { withFileTypes: true })
            .filter(d => d.isDirectory())
            .map(d => d.name);

          for (const vendorId of vendorDirs) {
            const vendorPath = path.join(galleryDir, vendorId);
            
            // Load vendor-level requirements.json if exists
            let vendorRequirements = null;
            const requirementsPath = path.join(vendorPath, 'requirements.json');
            if (fs.existsSync(requirementsPath)) {
              try {
                vendorRequirements = JSON.parse(fs.readFileSync(requirementsPath, 'utf8'));
              } catch (err) {
                console.error(`Error parsing ${requirementsPath}:`, err.message);
              }
            }
            
            const files = fs.readdirSync(vendorPath)
              .filter(f => f.endsWith('.yaml') || f.endsWith('.yml'));

            if (files.length === 0) continue;

            // Initialize vendor entries for both lists
            const createVendorEntry = () => ({
              id: vendorId,
              name: vendorNames[vendorId] || vendorId,
              requirements: vendorRequirements,
              items: []
            });

            for (const file of files) {
              const filePath = path.join(vendorPath, file);
              const content = fs.readFileSync(filePath, 'utf8');
              
              try {
                const doc = yaml.load(content);
                if (!doc.meta) continue;

                // Check if has parameters or discovery section
                const hasParameters = Array.isArray(doc.parameters) && doc.parameters.length > 0;
                const hasDiscovery = doc.discovery !== undefined && doc.discovery !== null;
                const hasAdvancedFeatures = hasParameters || hasDiscovery;

                // Count entities, automations, and scripts
                const contentSummary = {
                  entities: {},
                  automations: 0,
                  scripts: 0
                };

                if (doc.entities) {
                  for (const [type, items] of Object.entries(doc.entities)) {
                    if (Array.isArray(items)) {
                      contentSummary.entities[type] = items.length;
                    }
                  }
                }

                if (doc.automation && Array.isArray(doc.automation)) {
                  contentSummary.automations = doc.automation.length;
                }

                if (doc.scripts && Array.isArray(doc.scripts)) {
                  contentSummary.scripts = doc.scripts.length;
                }

                const item = {
                  file: `${vendorId}/${file}`,
                  name: doc.meta.name || file,
                  name_en: doc.meta.name_en || null,
                  description: doc.meta.description || '',
                  description_en: doc.meta.description_en || null,
                  version: doc.meta.version || '1.0.0',
                  author: doc.meta.author || 'unknown',
                  tags: doc.meta.tags || [],
                  parameters: Array.isArray(doc.parameters) ? doc.parameters : [],
                  content_summary: contentSummary
                };

                // Add to appropriate list based on features
                // - hasParameters: list_new.json only (requires new UI)
                // - discovery only (no parameters): both lists (legacy compatible)
                // - neither: list.json only
                if (hasParameters) {
                  // Has parameters - new list only
                  if (!vendorsNew[vendorId]) {
                    vendorsNew[vendorId] = createVendorEntry();
                  }
                  vendorsNew[vendorId].items.push(item);
                } else {
                  // No parameters - add to legacy list
                  if (!vendorsLegacy[vendorId]) {
                    vendorsLegacy[vendorId] = createVendorEntry();
                  }
                  vendorsLegacy[vendorId].items.push(item);
                  
                  // Also add to new list if has discovery
                  if (hasDiscovery) {
                    if (!vendorsNew[vendorId]) {
                      vendorsNew[vendorId] = createVendorEntry();
                    }
                    vendorsNew[vendorId].items.push(item);
                  }
                }
              } catch (err) {
                console.error(`Error parsing ${filePath}:`, err.message);
              }
            }
          }

          // Generate list.json (without parameters/discovery)
          const resultLegacy = {
            generated_at: new Date().toISOString(),
            vendors: Object.values(vendorsLegacy).filter(v => v.items.length > 0)
          };

          fs.writeFileSync(
            path.join(galleryDir, 'list.json'),
            JSON.stringify(resultLegacy, null, 2)
          );

          console.log('Generated list.json with', resultLegacy.vendors.length, 'vendors');

          // Generate list_new.json (with parameters/discovery)
          const resultNew = {
            generated_at: new Date().toISOString(),
            vendors: Object.values(vendorsNew).filter(v => v.items.length > 0)
          };

          fs.writeFileSync(
            path.join(galleryDir, 'list_new.json'),
            JSON.stringify(resultNew, null, 2)
          );

          console.log('Generated list_new.json with', resultNew.vendors.length, 'vendors');
          EOF

      - name: Commit list.json and list_new.json
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add gallery/list.json gallery/list_new.json
          git diff --staged --quiet || git commit -m "chore: update gallery list.json and list_new.json [skip ci]"
          git push
